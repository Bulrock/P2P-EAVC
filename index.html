<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>P2P E2E AV Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="favicon.ico" />

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, #0f172a, #020617);
    }

    header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #1f2937;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    header span {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .lock-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.15rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #22c55e33;
      font-size: 0.7rem;
      color: #a7f3d0;
      background: #022c2255;
    }

    main {
      flex: 1;
      display: grid;
      gap: 1rem;
      padding: 1rem;
    }

    @media (min-width: 900px) {
      main {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    .card {
      background: #020617;
      border-radius: 1rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.7);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .card h2 {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .card h3 {
      margin: 0.7rem 0 0.3rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .pill {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      background: #111827;
      border: 1px solid #374151;
      color: #9ca3af;
    }

    button {
      border-radius: 999px;
      padding: 0.4rem 0.8rem;
      border: none;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #0ea5e9;
      color: #0b1120;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease;
      box-shadow: 0 10px 30px rgba(56, 189, 248, 0.35);
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      box-shadow: none;
      border: 1px solid #374151;
    }

    button.small {
      padding: 0.25rem 0.55rem;
      font-size: 0.7rem;
      border-radius: 999px;
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      background: #38bdf8;
      transform: translateY(-1px);
    }

    button:not(:disabled):active {
      transform: translateY(0);
      box-shadow: none;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      min-height: 70px;
      resize: vertical;
      border-radius: 0.7rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      padding: 0.4rem 0.5rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
    }

    textarea:focus-visible {
      outline: 1px solid #0ea5e9;
      border-color: #0ea5e9;
    }

    .row {
      display: flex;
      gap: 0.4rem;
      align-items: center;
      justify-content: space-between;
      margin-top: 0.1rem;
    }

    .row > *:first-child {
      flex: 1;
    }

    .copy-status {
      font-size: 0.7rem;
      color: #9ca3af;
      text-align: right;
      min-height: 0.9rem;
    }

    .status-line {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      margin-right: 0.35rem;
      display: inline-block;
      background: #f97316;
      box-shadow: 0 0 10px rgba(249, 115, 22, 0.6);
    }

    .status-dot.connected {
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.7);
    }

    .status-dot.disconnected {
      background: #ef4444;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.7);
    }

    .videos {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    video {
      width: 100%;
      background: #020617;
      border-radius: 0.7rem;
      border: 1px solid #1f2937;
      max-height: 220px;
      object-fit: cover;
    }

    .label {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.15rem;
    }

    .logs {
      flex: 1;
      min-height: 80px;
      max-height: 180px;
      overflow-y: auto;
      border-radius: 0.7rem;
      border: 1px solid #1f2937;
      background: radial-gradient(circle at top left, #020617, #020617);
      padding: 0.4rem 0.5rem;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
    }

    .chat-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chat-messages {
      flex: 1;
      border-radius: 0.7rem;
      border: 1px solid #1f2937;
      background: #020617;
      padding: 0.4rem 0.5rem;
      font-size: 0.78rem;
      overflow-y: auto;
    }

    .msg {
      margin-bottom: 0.3rem;
      display: flex;
    }

    .msg.me {
      justify-content: flex-end;
    }

    .bubble {
      max-width: 80%;
      padding: 0.3rem 0.55rem;
      border-radius: 0.8rem;
      border-bottom-left-radius: 0.3rem;
      background: #111827;
      border: 1px solid #1f2937;
    }

    .msg.me .bubble {
      background: #0ea5e9;
      color: #0b1120;
      border-color: #38bdf8;
      border-bottom-right-radius: 0.3rem;
      border-bottom-left-radius: 0.8rem;
    }

    .bubble small {
      display: block;
      font-size: 0.6rem;
      opacity: 0.75;
    }

    .chat-input-row {
      display: flex;
      gap: 0.4rem;
      align-items: center;
    }

    .chat-input-row input {
      flex: 1;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      padding: 0.35rem 0.6rem;
      font-size: 0.8rem;
    }

    .chat-input-row input:focus-visible {
      outline: 1px solid #0ea5e9;
      border-color: #0ea5e9;
    }

    footer {
      padding: 0.4rem 1.2rem 0.8rem;
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      border-top: 1px solid #111827;
    }
  </style>
</head>
<body>
  <header>
    <div class="lock-badge">
      <span>ðŸ”’ E2E P2P</span>
      <span>AES-256 â€¢ WebRTC</span>
    </div>
    <div>
      <h1>P2P Encrypted AV Chat</h1>
      <span>Messages & keys live only in this tab.</span>
    </div>
  </header>

  <main>
    <!-- LEFT: Signaling + video -->
    <section class="card" id="left-card">
      <h2>
        Connection & Media
        <span class="status-line">
          <span id="connDot" class="status-dot"></span><span id="connStatus">Disconnected</span>
        </span>
      </h2>

      <div>
        <h3>
          Host flow
          <span class="pill">You start the call</span>
        </h3>
        <div class="row">
          <button id="btnCreateOffer">1. Host: Create offer</button>
          <button id="btnReset" class="secondary small">Reset</button>
        </div>
        <div class="label">Offer blob (send to guest)</div>
        <div class="row">
          <textarea id="offerOut" placeholder="After creating the offer, this field will contain the host blob."></textarea>
          <button class="secondary small" id="btnCopyOffer">Copy</button>
        </div>

        <div class="label">Answer blob from guest</div>
        <div class="row">
          <textarea id="answerIn" placeholder="Paste the answer blob from the guest here."></textarea>
          <button class="secondary small" id="btnApplyAnswer">Apply</button>
        </div>

        <div class="copy-status" id="copyStatus"></div>
      </div>

      <div>
        <h3>
          Guest flow
          <span class="pill">You join the call</span>
        </h3>

        <div class="label">Offer blob from host</div>
        <textarea id="offerIn" placeholder="Paste the offer blob from the host here."></textarea>
        <div class="row">
          <button id="btnAcceptOffer">2. Guest: Accept offer</button>
          <button id="btnCopyAnswerGuest" class="secondary small">Copy answer</button>
        </div>

        <div class="label">Your answer blob (send back to host)</div>
        <textarea id="answerOut" placeholder="After accepting, this field will contain your answer blob."></textarea>
      </div>

      <div>
        <h3>Media</h3>
        <div class="videos">
          <div>
            <div class="label">You</div>
            <video id="localVideo" autoplay playsinline muted></video>
          </div>
          <div>
            <div class="label">Peer</div>
            <video id="remoteVideo" autoplay playsinline></video>
          </div>
        </div>
      </div>

      <div>
        <h3>Log</h3>
        <div class="logs" id="log"></div>
      </div>
    </section>

    <!-- RIGHT: Chat -->
    <section class="card" id="right-card">
      <h2>
        Secure chat
        <span class="pill">DataChannel + AES-GCM</span>
      </h2>

      <div class="chat-box">
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="Type a messageâ€¦" />
          <button id="btnSend">Send</button>
        </div>
        <div class="status-line">
          <span style="margin-right: 0.25rem;">ðŸ’¬</span>
          <span id="chatStatus">DataChannel: not ready</span>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <span>Close or reload this tab = all keys & messages gone.</span>
    <span>For most NATs youâ€™ll need both peers on relatively open networks (no TURN here).</span>
  </footer>

  <script>
    // --- Global state ---
    let pc = null;                  // RTCPeerConnection
    let dataChannel = null;         // RTCDataChannel
    let sharedKey = null;           // CryptoKey (AES-GCM)
    let localStream = null;
    let remoteStream = null;
    let isHost = null;              // true = host, false = guest

    const logEl = document.getElementById("log");
    const connDot = document.getElementById("connDot");
    const connStatus = document.getElementById("connStatus");
    const chatStatus = document.getElementById("chatStatus");
    const chatMessages = document.getElementById("chatMessages");
    const copyStatus = document.getElementById("copyStatus");

    const offerOut = document.getElementById("offerOut");
    const offerIn = document.getElementById("offerIn");
    const answerOut = document.getElementById("answerOut");
    const answerIn = document.getElementById("answerIn");
    const chatInput = document.getElementById("chatInput");

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");

    function log(message) {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      const ss = String(now.getSeconds()).padStart(2, "0");
      const line = `[${hh}:${mm}:${ss}] ${message}`;
      console.log(line);
      if (!logEl) return;
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setConnectionStatus(status) {
      connStatus.textContent = status;
      connDot.classList.remove("connected", "disconnected");
      if (status === "Connected") {
        connDot.classList.add("connected");
      } else if (status === "Disconnected") {
        connDot.classList.add("disconnected");
      }
    }

    function setChatStatus(text) {
      chatStatus.textContent = text;
    }

    function showCopyStatus(message) {
      copyStatus.textContent = message;
      if (!message) return;
      setTimeout(() => {
        if (copyStatus.textContent === message) {
          copyStatus.textContent = "";
        }
      }, 2000);
    }

    function resetState() {
      if (pc) {
        pc.ontrack = null;
        pc.ondatachannel = null;
        pc.onicecandidate = null;
        pc.oniceconnectionstatechange = null;
        pc.close();
      }
      if (dataChannel) {
        dataChannel.onopen = null;
        dataChannel.onclose = null;
        dataChannel.onmessage = null;
        dataChannel.close();
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
      }

      pc = null;
      dataChannel = null;
      sharedKey = null;
      localStream = null;
      remoteStream = null;
      isHost = null;

      offerOut.value = "";
      offerIn.value = "";
      answerOut.value = "";
      answerIn.value = "";

      if (localVideo) localVideo.srcObject = null;
      if (remoteVideo) remoteVideo.srcObject = null;
      if (chatMessages) chatMessages.innerHTML = "";

      logEl.textContent = "";
      setConnectionStatus("Disconnected");
      setChatStatus("DataChannel: not ready");
      showCopyStatus("");
      log("Ready. Create an offer to start.");
    }

    // --- Crypto helpers (AES-GCM) ---
    async function generateSharedKey() {
      return crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
    }

    async function exportKeyJwk(key) {
      return crypto.subtle.exportKey("jwk", key);
    }

    async function importKeyJwk(jwk) {
      return crypto.subtle.importKey(
        "jwk",
        jwk,
        { name: "AES-GCM" },
        true,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptMessage(key, message) {
      const enc = new TextEncoder();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        enc.encode(message)
      );
      const combined = new Uint8Array(iv.byteLength + ciphertext.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(ciphertext), iv.byteLength);
      return combined.buffer;
    }

    async function decryptMessage(key, data) {
      const combined = new Uint8Array(data);
      const iv = combined.slice(0, 12);
      const ciphertext = combined.slice(12);
      const plaintext = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        ciphertext
      );
      return new TextDecoder().decode(plaintext);
    }

    // --- WebRTC helpers ---
    function createPeerConnection() {
      const config = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" }
        ]
      };

      pc = new RTCPeerConnection(config);

      pc.oniceconnectionstatechange = () => {
        const state = pc.iceConnectionState;
        log(`ICE connection state: ${state}`);
        if (state === "connected" || state === "completed") {
          setConnectionStatus("Connected");
        } else if (state === "disconnected" || state === "failed") {
          setConnectionStatus("Disconnected");
        }
      };

      pc.ontrack = (event) => {
        log("Remote media stream attached.");
        if (!remoteStream) {
          remoteStream = new MediaStream();
        }
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
        remoteVideo.srcObject = remoteStream;
      };

      pc.ondatachannel = (event) => {
        // This is used by the guest side when host created the channel
        log("DataChannel received (guest).");
        dataChannel = event.channel;
        setupDataChannelHandlers();
      };

      return pc;
    }

    function setupDataChannelHandlers() {
      if (!dataChannel) return;
      dataChannel.onopen = () => {
        log("DataChannel open. You can chat now.");
        setChatStatus("DataChannel: open");
      };
      dataChannel.onclose = () => {
        log("DataChannel closed.");
        setChatStatus("DataChannel: closed");
      };
      dataChannel.onerror = (err) => {
        log("DataChannel error: " + err);
      };
      dataChannel.onmessage = async (event) => {
        if (!sharedKey) {
          log("Received message but sharedKey is missing.");
          return;
        }
        try {
          const text = await decryptMessage(sharedKey, event.data);
          appendChatMessage("peer", text);
        } catch (e) {
          log("Failed to decrypt incoming message: " + e);
        }
      };
      setChatStatus("DataChannel: connectingâ€¦");
    }

    async function waitForIceGatheringComplete(pc) {
      if (pc.iceGatheringState === "complete") {
        log("ICE gathering complete.");
        return;
      }
      await new Promise((resolve) => {
        pc.addEventListener("icegatheringstatechange", function handler() {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", handler);
            log("ICE gathering complete.");
            resolve();
          }
        });
      });
    }

    async function getLocalMedia() {
      log("Acquiring local mediaâ€¦");
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true
      });
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      localVideo.srcObject = localStream;
      log("Local media stream acquired.");
    }

    // --- Chat UI ---
    function appendChatMessage(from, text) {
      const div = document.createElement("div");
      div.className = "msg " + (from === "me" ? "me" : "peer");
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      const who = from === "me" ? "You" : "Peer";
      const small = document.createElement("small");
      small.textContent = who;
      const p = document.createElement("div");
      p.textContent = text;
      bubble.appendChild(small);
      bubble.appendChild(p);
      div.appendChild(bubble);
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // --- Button handlers ---
    document.getElementById("btnCreateOffer").addEventListener("click", async () => {
      try {
        resetState();
        isHost = true;
        log("Starting offer creationâ€¦");
        createPeerConnection();

        sharedKey = await generateSharedKey();
        log("Shared AES key generated.");

        await getLocalMedia();

        // Host creates DataChannel
        dataChannel = pc.createDataChannel("chat");
        log("DataChannel created (host).");
        setupDataChannelHandlers();

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log("Local description set, waiting for ICE gathering completeâ€¦");

        await waitForIceGatheringComplete(pc);
        const keyJwk = await exportKeyJwk(sharedKey);

        const blob = {
          role: "host",
          sdp: pc.localDescription,
          key: keyJwk
        };
        const base64 = btoa(JSON.stringify(blob));
        offerOut.value = base64;
        log("Offer blob ready. Copy and send it to your peer.");
      } catch (e) {
        log("Error while creating offer: " + e);
      }
    });

    document.getElementById("btnAcceptOffer").addEventListener("click", async () => {
      try {
        const base64 = offerIn.value.trim();
        if (!base64) {
          log("No offer blob provided.");
          return;
        }
    
        resetState();
        isHost = false;
    
        log("Accepting remote offerâ€¦");
        const blob = JSON.parse(atob(base64));
        if (!blob.sdp || !blob.key) {
          log("Invalid offer blob.");
          return;
        }
    
        createPeerConnection();
        sharedKey = await importKeyJwk(blob.key);
        log("Shared AES key imported from offer.");
    
        await pc.setRemoteDescription(blob.sdp);
        log("Remote description set from offer.");
    
        await getLocalMedia();
    
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        log("Local answer created, waiting for ICE gathering completeâ€¦");
    
        await waitForIceGatheringComplete(pc);
    
        const answerBlob = {
          role: "guest",
          sdp: pc.localDescription
        };
        answerOut.value = btoa(JSON.stringify(answerBlob));
        log("Answer blob ready. Copy and send it back to the host.");
      } catch (e) {
        log("Error while accepting offer: " + e);
      }
    });

    document.getElementById("btnApplyAnswer").addEventListener("click", async () => {
      try {
        if (!pc || !isHost) {
          log("You must be the host and have an active offer first.");
          return;
        }
        const base64 = answerIn.value.trim();
        if (!base64) {
          log("No answer blob provided.");
          return;
        }
        log("Applying remote answerâ€¦");
        const blob = JSON.parse(atob(base64));
        if (!blob.sdp) {
          log("Invalid answer blob.");
          return;
        }
        await pc.setRemoteDescription(blob.sdp);
        log("Remote description set from answer.");
      } catch (e) {
        log("Error while applying answer: " + e);
      }
    });

    document.getElementById("btnCopyOffer").addEventListener("click", async () => {
      if (!offerOut.value.trim()) return;
      try {
        await navigator.clipboard.writeText(offerOut.value.trim());
        showCopyStatus("Offer blob copied to clipboard.");
      } catch {
        showCopyStatus("Clipboard error (permissions?).");
      }
    });

    document.getElementById("btnCopyAnswerGuest").addEventListener("click", async () => {
      if (!answerOut.value.trim()) return;
      try {
        await navigator.clipboard.writeText(answerOut.value.trim());
        showCopyStatus("Answer blob copied to clipboard.");
      } catch {
        showCopyStatus("Clipboard error (permissions?).");
      }
    });

    document.getElementById("btnSend").addEventListener("click", async () => {
      const text = chatInput.value.trim();
      if (!text) return;
      if (!dataChannel || dataChannel.readyState !== "open") {
        log("DataChannel not open; cannot send.");
        return;
      }
      if (!sharedKey) {
        log("No shared key; cannot encrypt.");
        return;
      }
      try {
        const encrypted = await encryptMessage(sharedKey, text);
        dataChannel.send(encrypted);
        appendChatMessage("me", text);
        chatInput.value = "";
      } catch (e) {
        log("Failed to send encrypted message: " + e);
      }
    });

    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        document.getElementById("btnSend").click();
      }
    });

    document.getElementById("btnReset").addEventListener("click", () => {
      resetState();
    });

    // Init
    resetState();

    window.addEventListener("beforeunload", () => {
      if (pc) pc.close();
      if (dataChannel) dataChannel.close();
      if (localStream) localStream.getTracks().forEach(t => t.stop());
    });
  </script>
</body>
</html>
